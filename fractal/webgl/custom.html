<!DOCTYPE html>
<html>
<head><style>input{  
border:none;
  widthï¼š1000px;
  outline:medium;
  }
  </style></head>
<body>

<canvas id='c'></canvas><br>
<div id='d'></div>
Type:<select id='type'>
<option value='0'>julia</option><option value='1'>mandelbrot</option>
</select><br>
Mode:<select id="mode"><option value='0'>divergent</option><option value='1'>convergent</option></select>
Fractal formula:<input type='text' id='frac' value='sqr(z)+c'><br>
Inversion:<select id='inv'>
<option value='0'>normal</option><option value='1'>inverted</option>
</select>
<div id='adjt'>Adjust type:constant</div><br>
functions:mult for complex number multiplication,rec for 1/x,div for x/y<br>
i is imaginary unit<br>
built-in functions:Sin,Cos,Exp,Pow<br>
c is the constant,R is relation number,zold is last iteration point

<script id='v' type='x-shader/x-vertex'>
attribute vec4 a;
void main(){gl_Position=vec4(a);gl_PointSize=1.0;}
</script>

<script id='f' type='x-shader/x-fragment'>
#ifdef GL_ES
precision highp float;
#endif
uniform vec2 ce;uniform vec2 s;uniform float mode;uniform float type;
uniform float id;uniform float inverted;uniform vec2 R1;
vec2 i=vec2(0,1);
float es=64.0;float r=min(ce.x,ce.y)*0.5;
vec2 R=2.0*(R1-ce)/r;
float A=0.0;float B=-1.0;
vec2 L(){float x=sqrt(abs(A*A+4.0*B));
if(A*A+4.0*B<0.0){return vec2(A/2.0,x/2.0);}else{return vec2((A+x)/2.0,0.0);}}
//functions
vec2 mult(vec2 x,vec2 y){return vec2(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);}
vec2 sqr(vec2 x){return mult(x,x);}
float M(vec2 x){return sqrt(x.x*x.x+x.y*x.y);}
vec2 rec(vec2 x){
float x1=x.x*x.x+x.y*x.y;
return vec2(x.x/x1,-x.y/x1);
}
vec2 div(vec2 x,vec2 y){return mult(x,rec(y));}
vec2 cbr(vec2 x){
return vec2(x.x*x.x*x.x-3.0*x.x*x.y*x.y,
3.0*x.x*x.x*x.y-x.y*x.y*x.y);
}
float cosh(float x){return (exp(x)+exp(-x))/2.0;}
float sinh(float x){return (exp(x)-exp(-x))/2.0;}
vec2 Sin(vec2 x){return vec2(sin(x.x)*cosh(x.y),cos(x.x)*sinh(x.y));}
vec2 Cos(vec2 x){return vec2(cos(x.x)*cosh(x.y),-sin(x.x)*sinh(x.y));}
vec2 Exp(vec2 x){return exp(x.x)*vec2(cos(x.y),sin(x.y));}
vec2 Ln(vec2 x){return vec2(log(M(x)),atan(x.y,x.x));}
vec2 Pow(vec2 x,vec2 y){if(x.x==0.0&&x.y==0.0){return vec2(0,0);}else{return Exp(mult(y,Ln(x)));}}

//functions of arbitary complex
vec2 cons(vec2 x,vec2 y){return div(B*x,L())+mult(L(),y)+mult(x-y,vec2(0,1));}
//x is f(z.x+L()*z.y),y is f(z.x-B*z.y/L())
vec2 cons1(vec2 x){return vec2(x.x,0.0)+x.y*L();}
vec2 cons2(vec2 x){return vec2(x.x,0.0)+x.y*B*rec(L());}
vec2 multa(vec2 x,vec2 y){return vec2(x.x*y.x+B*x.y*y.y,x.x*y.y+x.y*y.x+A*x.y*y.y);}
vec2 Sina(vec2 x){return cons(Sin(cons1(x)),Sin(cons2(x)));}
vec2 Cosa(vec2 x){return cons(Cos(cons1(x)),Cos(cons2(x)));}
vec2 Expa(vec2 x){return cons(Exp(cons1(x)),Exp(cons2(x)));}
vec2 Lna(vec2 x){return cons(Ln(cons1(x)),Ln(cons2(x)));}


bool isConv(vec2 x,vec2 x_pre){
float dist=M(x-x_pre);
return (dist<es&&mode==0.0)||(dist>1.0/es&&mode==1.0);
}
vec2 zold=vec2(0,0);
//built-in fractals
vec2 fJ(vec2 x,vec2 c){return sqr(x)+c;}
vec2 fN(vec2 x,vec2 c){return mult(vec2(1,0)-R/3.0,x)+mult(R,rec(sqr(x))/3.0)+c;}
vec2 fBs(vec2 x,vec2 c){return vec2(x.x*x.x-x.y*x.y+c.x,abs(x.x*x.y)*2.0+c.y);}
vec2 fL(vec2 x,vec2 c){return mult(c,x-sqr(x));}
vec2 fM1(vec2 x,vec2 c){return sqr(div(sqr(x)+c-vec2(1,0),2.0*x+c-vec2(2,0)));}
vec2 fM2(vec2 x,vec2 c){return sqr(vec2(1,0)+div(cbr(x-vec2(1,0)),sqr(c)+3.0*mult(x+c-vec2(1,0),x-vec2(1,0))));}
vec2 fP(vec2 x,vec2 c){return sqr(x)+mult(R,zold)+c;}
vec2 fBf(vec2 x,vec2 c){vec2 x1=vec2(abs(x.x),abs(x.y));return sqr(x1)-x1+c;}
vec2 fj(vec2 x,vec2 c){return c+Pow(x,R);}
vec2 fn(vec2 x,vec2 c){return mult(x,vec2(1,0)-rec(R))+div(Pow(x,vec2(1,0)-R),R)+c;}
//main function
vec2 f(vec2 z,vec2 c){return vec2(11,11);}


void main(){
vec2 fr=vec2(gl_FragCoord);
vec2 cpre=(s-ce)/r;vec2 zpre=(fr-ce)/r;
vec2 z;vec2 C;
if(inverted==1.0){zpre=rec(zpre);}
if(type==0.0){z=zpre;C=cpre;}else if(type==1.0){z=cpre;C=zpre;}else{z=zpre;C=zpre;}
float I=0.0;
for(int j=0;j<100;j++){
if(isConv(z,zold)){
I++;vec2 z1=f(z,C);
zold=z;
z=z1;
}else{
break;
}
}
I=sqrt(I)/10.0;
gl_FragColor=vec4(I,I,I,1);}
</script>


<script>
var E=(x)=>document.getElementById(x)
var ca=E('c');gl=ca.getContext('webgl')
var vs=E('v').innerText;fs=E('f').innerText
var S='sqr(z)+c';fs1=fs.replace('vec2(11,11)',S)
var p=gl.createProgram()
var V=gl.createShader(gl.VERTEX_SHADER)
var F=gl.createShader(gl.FRAGMENT_SHADER)
gl.shaderSource(V,vs);gl.shaderSource(F,fs1)
gl.compileShader(V);gl.compileShader(F)
gl.attachShader(p,V);gl.attachShader(p,F)
gl.linkProgram(p)
gl.useProgram(p)
var vtc=new Float32Array([-1,1,1,1,1,-1,-1,1,1,-1,-1,-1])//vertices


var Mode=0;Type=0
//mode 0 for divergent,1 for convergent
//type 0 for julia,1 for mandelbrot

//nothing here lmao

var w=window.innerWidth;h=window.innerHeight
ca.width=w;ca.height=h
var id=0
var inverted=0

var b=gl.createBuffer()
var ab=gl.ARRAY_BUFFER
gl.bindBuffer(ab,b);gl.bufferData(ab,vtc,gl.STATIC_DRAW)
var a=gl.getAttribLocation(p,'a')
gl.enableVertexAttribArray(a)
gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0)
var c=gl.getUniformLocation(p,'ce');gl.uniform2fv(c,[w/2,h/2])//center
var s=gl.getUniformLocation(p,'s');gl.uniform2fv(s,[w/2,h/2])
var R=gl.getUniformLocation(p,'R1');gl.uniform2fv(R,[w/2+h/8,h/2])
var mode=gl.getUniformLocation(p,'mode')
var type=gl.getUniformLocation(p,'type')
var inv=gl.getUniformLocation(p,'inverted')
var Id=gl.getUniformLocation(p,'id')
function update(){
gl.uniform1f(mode,Mode);gl.uniform1f(type,Type);gl.uniform1f(Id,id);gl.uniform1f(inv,inverted);
}
var seed={x:w/2,y:h/2}
var rel={x:w/2+h/8,y:h/2}
var adjt=0
function split(x){let t=[];st=true;let y='';for(let i=0;i<x.length;i++){
y=x.charAt(i);if((y=='.'&&!st)||(parseFloat(y)==0||parseFloat(y))){
if(st){t.push(y);st=false}else{t[t.length-1]+=y}
}else{
t.push(y);st=true
}
};return t}
function float(x){var t='';y=split(x);y.forEach((z)=>{if(parseInt(z)==parseFloat(z)&&(parseInt(z)==0||parseInt(z))){t+=(z+'.0')}else{t+=z}});return t.replaceAll('vec2.0','vec2')}
ca.onmousemove=(event)=>{var event=event||window.event;
var x=event.offsetX;y=event.offsetY;
if(!adjt){seed.x=x;seed.y=y}else{rel.x=x;rel.y=y}
render()}
function render(){
gl.viewport(0,0,w,h)
if(!adjt){
gl.uniform2f(s,seed.x,seed.y)
}else{
gl.uniform2f(R,rel.x,rel.y)
}
gl.drawArrays(gl.TRIANGLES,0,6)
}
render()
function check(x){let S1=x;shader=gl.createShader(gl.FRAGMENT_SHADER)
gl.shaderSource(shader,fs.replace('vec2(11,11)',S1));gl.compileShader(shader);return gl.getShaderInfoLog(shader).length==0}
function updateShader(){gl.shaderSource(F,fs1);gl.compileShader(F);gl.linkProgram(p)
a=gl.getAttribLocation(p,'a')
gl.enableVertexAttribArray(a)
gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0)
c=gl.getUniformLocation(p,'ce');gl.uniform2fv(c,[w/2,h/2])
s=gl.getUniformLocation(p,'s');gl.uniform2fv(s,[w/2,h/2])
R=gl.getUniformLocation(p,'R1');gl.uniform2fv(R,[w/2+h/8,h/2])
mode=gl.getUniformLocation(p,'mode')
type=gl.getUniformLocation(p,'type')
inv=gl.getUniformLocation(p,'inverted')}
//htmls
function value(x){return parseFloat(E(x).value)}
E('type').onchange=function(){Type=value('type');update()}
E('mode').onchange=function(){Mode=value('mode');update()}
E('frac').onchange=function(){let S0=float(E('frac').value);
if(check(S0)){S=S0;fs1=fs.replace('vec2(11,11)',S);updateShader()}
update()}
E('inv').onchange=function(){inverted=value('inv');update()}
ca.onclick=function(){adjt=1-adjt;E('adjt').innerHTML='Adjust type:'+['constant','relation number'][adjt]}
//debug
function debug(){E('d').innerHTML='vertex shader:'+gl.getShaderInfoLog(V)+'<br>'+'fragment shader:'+gl.getShaderInfoLog(F)}
</script>
</body>
</html>
